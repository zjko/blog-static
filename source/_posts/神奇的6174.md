---
title: 神奇的6174
date: 2017-12-22 21:16:27
tags: [算法,C]
toc: true
---



## 问题描述

神奇的6174
1949年，印度数学家D.R.Kaprekar设计了一个现在被称为Kaprekar变换的操作：首先任选一个各位数字不全相同的四位数K0（即不是1111，2222，……，9999）， 然后把它各位数字重新排列，得到一个最大数和最小数，接着用最大数减去最小数得到一个新的数K1，重复以上操作不断得到新的数K2，K3，……。这是一个简单的变换，但D.R.Kaprekar发现，最多进行7次上述变换，就会得到6174。以四位数2316为例，步骤如下：
<!-- more -->

	K0=2316
	K1=6321-1236=5085 一次
	K2=8550-0558=7992 二次
	K3=9972-2799=7173 三次
	K4=7731-1377=6354 四次
	K5=6543-3456=3087 五次
	K6=8730-0378=8352 六次
	K7=8532-2358=6174 七次
当我们得到6174这个数后，以后每一步都重复6174这个数。
现在要你写一个程序来判断一个四位数经过多少次这样的操作能出现循环，并且求出操作的次数。比如输入1234执行顺序是1234->3087->8352->6174->6174,输出是3。
输入：
第一行输入n,代表有n组测试数据。
接下来n行每行给出一个各位数不全相同的四位数
输出：
经过多少次上面描述的操作才能出现循环。
输入样例：

	2
	1234
	2316
输出样例：

	3
	7
输入样例：

	1
	2333
输出样例：

	5

[代码地址](https://github.com/zjko/Algorithm/blob/master/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%A5%9E%E5%A5%87%E7%9A%846174.cpp)

## 问题分析
这个问题可以看成一个十以内的四位数排序问题。

### 桶排序
因为这个问题的数据空间十分小，一共只有0~9十个数据，我们可以采用最快的桶排序方法。
定义一个数组sort[10],然后分别将这些数据丢到对应的桶子里去就行了（例子，sort[3]表示3这个数字出现的次数）。最后从左到右，组合便是能够构成的最小数据，从右往左组合，便是最大的数据。大数减去小数，重新排序，直到出现6174为止。
