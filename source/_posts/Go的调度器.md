---
title: 【转载】Go的调度器
date: 2018-08-25 20:33:41
tags: [Go]
toc: true
---

原文： http://morsmachine.dk/go-scheduler

Go 1.1的一大特色是新调度程序，由Dmitry Vyukov提供。新的调度程序使并行Go程序的性能大幅提升。

### 为什么需要一个Go调度器
操作系统提供了线程调度方式，为什么还需要一个go调度器？
<!-- more -->
* POSIX线程API是对已有的UNIX进程模型的逻辑扩展，因此，线程和进程有很多类似的地方，如线程有自己的信号掩码，可以分配CPU亲和力，可以放入cgroups，但是有很多特性对于Go程序来说都是累赘。

* 另一个问题是OS无法根据Go模型做出明智的调度决策。例如，Go垃圾收集器要求在运行时停止所有线程，并且该内存必须处于一致状态。垃圾回收时间点是无法确定的，如果让OS来调度则会导致大量线程停止工作。

* 当你在随机点安排了很多线程时，你可能不得不等待很多线程达到一致状态。Go调度程序可以决定仅在知道内存一致的点上进行调度。这意味着当我们停止垃圾收集时，我们只需要等待在CPU核心上主动运行的线程。

### Go调度器的工作

有三种常用的线程模型。
1. N：1，其中一个用户空间线程在一个OS线程上运行。这具有快速上下文切换但不能利用多核系统的优点。
2. 1:1模型，1个内核空间线程运行一个用户空间线程。这种充分利用了多核系统的优势但是上下文切换非常慢，因为每一次调度都会在用户态和内核态之间切换。
3. M:N模型， 每个用户线程对应多个内核空间线程，同时也可以一个内核空间线程对应多个用户空间线程。Go打算采用这种模型，使用任意个内核模型管理任意个goroutine。这样结合了以上两种模型的优点，但缺点就是调度的复杂性。

Go试图通过M：N的调度器去获取这两个世界的全部优势。它在任意数目的OS线程上调用任意数目的goroutines。你可以快速进行上下文切换，并且还能利用你系统上所有的核心的优势。这个模型主要的缺点是它增加了调度器的复杂性。
![图示](https://img3.doubanio.com/view/note/large/public/p9619631.jpg)

* **M表示OS线程**，它是由OS管理的可执行程序的一个线程，而且工作起来特别像你的标准POSIX线程。在运行时代码里，它被成为M，即机器（machine）。
* **G表示goroutine**，它包括栈、指令指针以及对于调用goroutines很重要的其它信息，比如阻塞它的任何channel。在可执行代码里，它被称为G。
* **P小时调用的上下文**，你可以把它看作在一个单线程上运行代码的调度器的一个本地化版本。它是让我们从N：1调度器转到M：N调度器的重要部分。在运行时代码里，它被叫做P，即处理器（processor）。

![图示](https://img3.doubanio.com/view/note/large/public/p9619633.jpg)

可以从上面的图里看到两个线程（M），每个线程都拥有一个上下文（P），每个线程都正在运行一个goroutine（G）。为了运行goroutines，一个线程必须拥有一个上下文。

上下文的数目在启动时被设置为环境变量GOMAXPROCS的值或者通过运行时函数GOMAXPROCS()来设置。通常，在你的程序执行时它不会发生变化。上下文的数目被固定的意思是，只有GOMAXPROCS个上下文正在任意点上运行Go代码。我们可以使用GOMAXPROCS调整Go进程的调用使其适合于一个单独的计算机，比如一个4核的PC中可以在4个线程上运行Go代码。

`外部的灰色goroutines没在运行，但是已经准备好被调度了。它们被安排成一个叫做runqueue的列表。当一个goroutine执行一个go 语句的时候，goroutine就被添加到runqueue的末端。一旦一个上下文已经运行一个goroutine到了一个点上，它就会把一个goroutine从它的runqueue给pop出来，设置栈和指令指针并且开始运行这个goroutine。`

为了降低mutex竞争，每一个上下文都有它自己的runqueue。Go调度器曾经的一个版本只有一个通过mutex来保护的全局runqueue，线程们经常被阻塞来等待mutex被解除阻塞。当你有许多32核的机器而且想尽可能地压榨它们的性能时，情况就会变得相当坏。

只要所有的上下文都有goroutines要运行，调度器就能在一个稳定的状态下保持调度。但是有几个你能改变的场景。

## 你打算（系统）调用谁？
你现在可能想知道，为什么一定要有上下文？我们能不能丢掉上下文而仅仅把runqueue放到线程上？不尽然。`我们用上下文的原因是如果正在运行的线程因为某种原因需要阻塞的时候，我们可以把这些上下文移交给其它线程`

我们需要阻塞的一个例子是，当我们需要调用一个系统调用的时候。因为一个线程不能既执行代码同时又阻塞到一个系统调用上，我们需要移交对应于这个线程的上下文以让这个上下文保持调度。
![图示](https://img1.doubanio.com/view/note/large/public/p9619637.jpg)

从上图我们能够看出，一个线程放弃了它的上下文以让另外的线程可以运行它。调度器确保有足够的线程来运行所有的上下文。上图中的M1 可能仅仅为了让它处理图中的系统调用而被创建出来，或者它可能来自一个线程池（thread cache）。这个处于系统调用中的线程将会保持在这个导致系统调用的goroutine上，因为从技术上来说，它仍然在执行，虽然阻塞在OS里了。

当这个系统调用返回的时候，这个线程必须尝试获取一个上下文来运行这个返回的goroutine，操作的正常模式是从其它所有线程中的其中一个线程中“偷”一个上下文。如果“偷盗”不成功，它就会把它的goroutine放到一个全局runqueue中，然后把自己放到线程池中或者转入睡眠状态。

这个全局runqueue是各个上下文在运行完自己的本地runqueue后用来获取新goroutine的地方。上下文也会周期性的检查这个全局runqueue上的goroutine，否则，全局runqueue上的goroutines可能得不到执行而饿死。

`Go程序要在多线程上运行的原因就是因为要处理系统调用，哪怕GOMAXPROCS等于1`。运行时(runtime)使用调用系统调用的goroutines，而不是线程。

## 盗取工作（Stealing work）
系统的稳定状态改变的另外一个方法是，当一个上下文运行完要被调度的所有goroutines的时候。如果各个上下文的runqueue里的工作的数目不均衡，改变就会发生了，否则会导致一个上下文在执行完它的runqueue后就会结束，尽管系统中仍然有许多工作要执行。所以为了保持运行Go代码，一个上下文能够从全局runqueue中获取goroutines，但是如果全局runqueue中也没有goroutines了，那么上下文就不得不从其它地方获取goroutines了。
![](https://img3.doubanio.com/view/note/large/public/p9619671.jpg)
这个“其它地方”指的是其它上下文！当一个上下文完成自己的任务后，它就会尝试“盗取”另一个上下文runqueue中工作量的一半。这将确保每个上下文总是有活干，然后反过来确保所有线程尽可能处于最大负荷。
如图所示两个上下文分别执行4个goroutines和0个goroutines，此时执行0个goroutines的上下文将会从执行4个goroutines上下文的runqueue拿到两个goroutines。